<!DOCTYPE html>
<html>
<head>
	<title>Демонстрация выбора направления</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
	<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
	<script src="leaflet.sector.js"></script>
	<style>
		html, body {
			height: 100%;
			margin: 0;
		}
		#map {
			width: 600px;
			height: 400px;
		}
	</style>
</head>
<body>

<div id='map'></div>
<script>
	var osmUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
			osmAttrib = '&copy; <a href="http://openstreetmap.org/copyright">OpenStreetMap</a> contributors',
			osm = L.tileLayer(osmUrl, { maxZoom: 20, attribution: osmAttrib }),
			map = new L.Map('map', { center: new L.LatLng( 59.6931881, 30.4437972), zoom: 16 }),
			drawnItems = L.featureGroup().addTo(map);
	L.control.layers({
		'osm': osm.addTo(map),
		"google": L.tileLayer('http://www.google.cn/maps/vt?lyrs=s@189&gl=cn&x={x}&y={y}&z={z}', {
			attribution: 'google'
		})
	}).addTo(map);

function Pseudoobj () {}	Pseudoobj.prototype = { // оболочка псевдокласса
	create: function (map) {
		this.map = map;	
		this.p = {};

				
		this.p.geoCalc = {};
		this.mode = 0;
		// 0 - выбор точки фотографа/худолжника this.φλ0
		// 1 - выбор направления/объекта по центру фото (азимута) this.φλ1 this.p.geoCalc.α this.p.geoCalc.Δl_m
		// 2 - выбор угла обзора this.β
		// 3 - резерв для высотной координаты
		// 4 - выбор сделан выбранной точки
		this.voidageGeoData(); // Сброс всех географических данных
		this.dir = [
			'n', 'n',
			'ne', 'ne', 'ne', 'ne',
			'e', 'e', 'e', 'e',
			'se', 'se', 'se', 'se',
			's', 's', 's', 's',
			'sw', 'sw', 'sw', 'sw',
			'w', 'w', 'w', 'w',
			'nw', 'nw', 'nw', 'nw',
			'n', 'n'
		]; // Индексы сторон света по долям в 11,25° 8 направлений
	/*	this.dir = [
			'n', 'nne', 'nee', 'ne', 'ne', 'nee', 'nee', 'e',
			'e', 'see', 'see', 'se', 'se', 'sse', 'sse', 's',
			's', 'ssw', 'sww', 'sw', 'sw', 'sww', 'sww', 'w',
			'w', 'nww', 'nww', 'nw', 'nw', 'nnw', 'nnw', 'n'
		]; // Индексы сторон света по долям в 11,25°, на 16 направлений */
	this.map.on('click', obj.onMapGeoSelectionClick, obj);
	this.map.addEventListener('mousemove', obj.onMapMouseMove, obj);
	},
	voidageGeoData : function () { // Очистка всех пространственных данных
		this.mode == 0;
		this.φλ0 = null; // Координаты фотографа/худоджника
		this.ini_marker = null; // Отметка начальной точки L.layer
		this.voidageDirection();
	},
	voidageDirection : function () { // Очистка направления
		this.mode == 1;
		this.φλ1 = null; // Координаты объекта по центру изображения
		this.racursmark = null; // Полная отметка ракурса L.layerGroup		
		this.sector = null; // Сектор обзора
		this.p.geoCalc.α = null; // Азимут центральнгой оси изображения
		this.p.geoCalc.Δl_m = null; // Метрическое расстояние между основными точками
		this.voidageObserveAngle();
	},
	voidageObserveAngle : function () { // Очистка угла обзора
		this.mode == 2;
		this.β = null; // Угол оси обзора
	},
	onMapGeoSelectionClick: function (e) {
		this.φλ = [e.latlng.lat, e.latlng.lng];
		if (this.mode == 0) { // выбор точки фотографа/худолжника
			this.φλ0 = this.φλ;
			if (this.racursmark)
				this.map.removeLayer(this.racursmark);
			if (this.ini_marker)
				this.map.removeLayer(this.ini_marker);
			this.ini_marker = L.marker(this.φλ0).bindPopup('Точка изображения').addTo(this.map);
			this.mode = 1;
			this.ini_marker.addEventListener('click', this.onCentralMarkerClick, this);
		} else if (this.mode == 1) { // выбор направления/объекта по центру фото (азимута)
			this.φλ1 = this.φλ;
			var rs = this.Δl_azimut(this.φλ0, this.φλ1);
			this.p.geoCalc.α = rs.α;
			this.p.geoCalc.Δl_m = rs.Δl_m;
			this.mode = 2;
		} else if (this.mode == 2) { // выбор угла обзора
			var φλ2 = this.φλ;
			this.β = Math.abs(this.Δl_azimut(this.φλ0, φλ2).α - this.p.geoCalc.α) * 2.0;
			var Δβ = this.β / 2.0;
			this.p.geoCalc.α1 = (this.p.geoCalc.α - Δβ);
			this.p.geoCalc.α2 = (this.p.geoCalc.α + Δβ);
			//	this.mode = 3;
			this.mode = 4;
			this.geoSelectionComplete();
		} else if (this.mode == 3) { // резерв для выбора высотной координаты
		}
	},
	viewSector : function (α, Δl_m, β) { // Сектор по азимуту, расстоянию и углу обзора
		var Δβ = β / 2.0;
		var α1 = (α - Δβ);
		var α2 = (α + Δβ);
		if (Δβ > 180.0){
			α1 += 180.0;
			α2 -= 180.0;
		}
		return L.sector({
			center: this.φλ0,
			innerRadius: 0,
			outerRadius: Δl_m,
			startBearing: α1,
			endBearing: α2,
			fill: true,
			fillColor: '#aa0000',
			fillOpacity: 0.3,
			color: '#FF0000',
			opacity: 0.1,
			weight: 0
		});
	},
	onMapMouseMove : function (e) {
		if (this.mode == 0) { // выбор точки фотографа/худолжника
			return;
		} else if (this.mode == 1) { // выбор направления/объекта по центру фото (азимута)
			if (this.racursmark)
				this.map.removeLayer(this.racursmark);
			var φλ_ = [e.latlng.lat, e.latlng.lng];
			var res = this.Δl_azimut (this.φλ0, φλ_);
			if (res.Δl_m < 0.001) // Расстояние слишком мало
				return;
			this.sector = this.viewSector(res.α, res.Δl_m, 45.0);
			this.racursmark = new L.LayerGroup();
			this.racursmark.addLayer(
				L.polyline(
					[this.φλ0, φλ_],
					{color: '#FF0000', weight: 1}
				)
			);
			this.racursmark.addLayer(this.sector);
			this.racursmark.addTo(this.map);
		} else if (this.mode == 2) { // выбор угла обзора
			if (this.sector)
				this.map.removeLayer(this.sector);
			var φλ_ = [e.latlng.lat, e.latlng.lng];
			var β = Math.abs(this.Δl_azimut(this.φλ0, φλ_).α - this.p.geoCalc.α) * 2.0;
			this.sector = this.viewSector(this.p.geoCalc.α, this.p.geoCalc.Δl_m, β);
			this.racursmark.addLayer(this.sector);
		} else if (this.mode == 3) { // резерв для выбора высотной координаты
		}
	},
	onCentralMarkerClick : function (e) {
		if (this.mode == 0) { // выбор точки фотографа/худолжника
			return;
		} else if (this.mode == 1) { // выбор направления/объекта по центру фото (азимута)
			this.φλ1 = null;
			this.mode = 4;
			this.geoSelectionComplete();
		} else if (this.mode == 2) { // выбор угла обзора
			this.β = null;
			this.mode = 4;
			this.geoSelectionComplete();
		} else if (this.mode == 3) { // резерв для выбора высотной координаты
		}
	},
	geoSelectionComplete : function (){
		// Использование полученных данных
		// this.φλ0 - точка фотографа / художника
		// this.φλ1 - целевой / центральный объект
		// this.p.geoCalc.α - центральный азимут изображения
		// this.p.geoCalc.Δl_m - расстояние между точками в метрах по формуле гаверсинусов
		// this.β - угол обзора
		// this.p.geoCalc.α1 - начальный азимут обзора
		// this.p.geoCalc.α2 - конечный азимут обзора

		console.log('Результат выбора точек и угла обзора');
		console.log('основа' , this.φλ0);
		console.log('центр' , this.φλ1);
		console.log('обзор' , this.β);
		console.log(this.p.geoCalc);

		L.popup().setLatLng(this.φλ0)
			.setContent("Δl ≈" + (this.p.geoCalc.Δl_m ? this.p.geoCalc.Δl_m.toFixed(2) : null) + " м, α ∡ ≈" + (this.p.geoCalc.α ? this.p.geoCalc.α.toFixed(3) : null) + "°, β ⏿ ≈" + (this.β ? this.β.toFixed(3) : null) + " </br>Направление: " + this.geo_α(this.p.geoCalc.α))
			.openOn(this.map);
		this.mode = 0;
	},
	geo_α : function (α) { // Латинский индекс направления по значению азимутального угла
		return α ? this.dir[Math.floor(α/11.25)] : null;
	},
	Δl_azimut : function (φλ0, φλ1) { // Функция определения азимута линии из точки 0 в точку 1 и примерного расстояния
		function rad (x)
			{ return x * Math.PI/180; }
		var φ1 = rad (φλ0[0]); var λ1 = rad (φλ0[1]);
		var φ2 = rad (φλ1[0]); var λ2 = rad (φλ1[1]);
		var Δφ = rad (φλ1[0]-φλ0[0]);
		var Δλ = rad (φλ1[1]-φλ0[1]);

		var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
			  Math.cos(φ1) * Math.cos(φ2) *
			  Math.sin(Δλ/2) * Math.sin(Δλ/2);
		var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

		const R_m = 6371e3; // r ♁
		var Δl_m = R_m * c;

		var y = Math.sin(λ2-λ1) * Math.cos(φ2);
		var x = Math.cos(φ1)*Math.sin(φ2) -
			  Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
		var θ = Math.atan2(y, x);
		var α = (θ*180/Math.PI + 360) % 360; // °
		return {
			Δl_m: Δl_m,
			α:α
		};
	}
};

	var obj = new Pseudoobj();
	obj.create(map);
</script>
</body>
</html>
